# 第二模块 函数编程

## 第一章 函数基础

### 1. 函数定义

函数是指将一组语句的集合通过一个名字(函数名)封装起来，要想执行这个函数，只需调用其函数名即可，在python中使用def来定义一个函数。

特点：

- 减少重复代码
- 使程序变的可扩展（使用*args, **kwargs）
- 使程序变得容易维护

函数调用时，首先会先申请一个内存空间来保存函数体代码，然后将内存地址和函数名绑定，并且在定义函数时，只检查语法，不会执行函数代码。

```python
'''
def 函数名(参数1,参数2,...):
    """文档描述"""
    函数体
    return 值
'''
```

### 2. 函数定义的三种方式：

- 无参数

- 有参数
- 空函数，使用pass来跳过函数

### 3. 函数调用的三种方式：

- 使用()调用
- 函数有返回值时，可以使用表达式调用
- 将返回值作为函数的参数继续调用

### 4. 函数返回值的三种形式

return是函数结束的标志，即函数体代码一旦运行到return就会立刻停止，并会将return后的值作为本次运行的结果返回，有三种返回值：

- 返回None：函数体没有return或return None
- 返回一个值：return 值
- 返回多个值：return+用逗号分隔开多个值，最后以元组的形式返回

## 第二章 函数的参数

### 1. 参数的定义

在定义函数或调用函数时，给函数添加值，就叫做函数的参数。

### 2. 形参的概念及三种类型

在函数的定义阶段，括号中声明的参数，称之为形参，类似于变量名，有三种形参：

- 位置形参：从左到右必须输入。
- 默认形参：定义阶段已经赋值，调用阶段可以不赋值，如果赋值则覆盖。
- 非固定参数：*args, **kwargs。

### 3. 实参的概念及三种类型

在函数的调用阶段，括号中传入的值，称之为实参，类似于变量值，有三种实参：

- 位置实参：从左到右进行输入。
- 可以修改默认形参的值：同上。
- 关键参数：将位置参数名进行key=value输入。

注意：在实参中同样可以出现*加元组或者字典，需要将其进行打散再对应操作。

如果在定义阶段使用了非固定参数，那么在调用阶段可以输入多个值，或多个关键参数，将被转换成元组和字典的形式。

## 第三章 名称空间和作用域

### 1. 名称空间的定义

名称空间就是存放名字与对象映射/绑定关系的地方，可以分为三种：

- 内建名称空间（built-in）：存放的python解释器内置的名字。
- 全局名称空间（global）：只要不是函数/内置的名字，其余都是全局名称空间。
- 局部名称空间（local）：在调用函数时运行函数体代码，产生的局部变量。

### 2. 名称空间的加载顺序及查找优先级

加载顺序：内建名称空间>全局名称空间>局部名称空间。

查找优先级：从当前所在位置一层层向上查找，且如果存在“嵌套”关系，则以定义时为准。

各个名称空间实际上没有嵌套关系，讲课只是为了方便理解，而且函数在定义阶段只会扫描代码，开辟空间，但是不会给变量赋值，只有当函数在调用阶段，才会给变量赋值。在定义函数的最顶行可以通过global xxx 来定义一个全局变量，或者使用nonlocal xxx来修改上一层函数的变量。

## 第四章 函数嵌套

**精髓：把函数当做变量去使用**

func = 内存地址，不加括号相当于内存地址，加括号相当于调用函数拿到返回值。具体用法如下：

- 赋值操作，f = func
- 当做参数，foo(func)
- 作为返回值，return func，在后面的语法糖会大量使用
- 作为容器中的一个元素，l = [func, ]，dic = {'k': func}

### 1. 嵌套函数

将大程序分解成一个个的小程序来实现，需要跟后面的语法糖结合使用。

### 2. 闭包函数

闭包函数实际上是名称空间与作用域+函数嵌套+函数对象这些知识的综合体现。

闭：指的是该函数是内嵌函数

包：指的是该函数对外层函数作用域名字的引用（不是对全局作用域）

```python
def f1():
	x = 333
	def f2():
		print(x)
    return f2
```



通过返回f2的内存地址，使得f2()在全局范围内可以直接调用。

闭包函数最大的作用实际上是提供了一种给函数体传参的新方法，除了在定义函数体时，定义形参外，也可以通过使用一个函数将函数包起来，给内函数传参。

### 第五章 装饰器

*args, **kwargs在形参中可以接受任意参数，他们位于实参时，需要将其打散对应。如果出现在一个形参位置，一个实参位置，那么两个位置的参数完全相同。名称空间的关系一定要在函数定义阶段进行判断，函数名实际上和变量名类似，都可以当做参数传入，当做返回值传出。注意：返回函数对象时，不能加括号，加括号就是调用函数得到返回值。函数的嵌套就是指，在一个函数中嵌套另一个函数，并在第一层函数返回第二层函数名，使得第二层函数也可以在全局进行调用。闭包函数，本质上是一个嵌套函数，但是第二层函数需要使用到第一层函数的变量。

### 1. 装饰器（又名语法糖）

装饰器指的是定义一个函数，在不修改被装饰对象源代码以及调用方式的前提下，给其他函数添加功能，如登陆功能，认证功能，好几个函数都需要类似的功能，使用装饰器就很方便。

### 2. 开放封闭原则

开放：指的是对拓展功能是开放的。

封闭：指的是对修改源代码是封闭的。

### 3. 语法糖用法

语法糖模板（无参装饰器）：

```python
def outer(func):
	def wrapper(*args, **kwargs):
		res = func(*args, **kwargs)
        return res
    return wrapper
```

在被装饰对象正上方的单独一行写@装饰器名字，上述代码中func就是被装饰对象。

偷梁换柱：将原函数名指向的内存地址偷梁换柱成wrapper函数，所以应该将wrapper做的跟原函数一样才行。

```python
from functools import wraps
	def outer(func):
		@wraps(func)
		def wrapper(*args, **kwargs):
```

由于语法糖的限制，outer函数只能有一个参数，并且只能用来接收被装饰对象的内存地址。如果下面的函数还需要其他参数，则需要再加一层函数来给下一层的函数传参。

```
def deco(x,y,z):  # 往往加属性参数
	def outer(func):
		def wrapper(*args, **kwargs):
			x = 1
			y = 1
			z = 1
			res = func(*args, **kwargs)
			return res
		return wrapper
	return outer
```

## 第六章 迭代器

### 1. 迭代器

迭代器指的是一种迭代取值的工具。

迭代是一个重复的过程，每次重复都是基于上一次的结果而继续，单纯的重复并不是迭代。

迭代器能够不依赖索引进行取值，并且占用的内存很小。

可迭代对象：但凡内置有```___iter__```方法的都称之为可迭代对象，通过调用```___iter__```方法会将其转换成迭代器对象，比如字典，字符串，列表等等。

迭代器对象：内置有```__next__```方法的称之为迭代器对象，比如文件。

### 2. for 循环的工作原理

for循环可以称之为迭代器循环，并且本质上就是while循环。

1. d_iter = iter(iterable)得到一个迭代器对象。
2. val = next(d_iter)拿到一个返回值，并将值赋给val。
3. 捕捉stopiteration来结束循环。

### 3. 迭代器优缺点总结

优点：

1. 统一。
2. 节省内存（惰性计算）。

缺点：

1. 无法随意取值。
2. 一次性，结束之后，必须再生成一个迭代器。

### 4. 自定义迭代器（生成器）

在函数内使用yield方法，一旦存在yield关键字，调用函数时，整个函数并不会执行，相反函数体代码会返回一个生成器对象，必须使用next方法来触发函数体代码的运行，然后在遇到yield时停下来，将yield后的值返回。

```python
def my_range(start, stop, step=1):
	if start < stop:
		yield start
		start += step
```

### 5. 叠加多个装饰器

1. 加载顺序自下而上
2. 执行顺序自上而下

### 6. yield表达式

只要函数体内存在yield，则函数体的代码全部不执行，编程生成器，必须使用next方法来调用。

x = yield 返回值

g = dog('name')不执行函数

next(g)开始执行

g.send('alex')可以使用send方法来对yield进行传值

g.close()关闭之后，不可以再继续传值

### 7. 三元表达式

语法格式：条件成立时返回的值 if条件 else 条件不成立返回的值

1. 列表生成式：new_l = [name for name in l if name.endswith('dsb') else name + 'dsb']
2. 集合、字典生成式：res = {k : v for k, v in items if k != 'gender'}
3. 生成器表达式：g = (i for i in range(10) if i < 3)此刻内部一个值都没有，需要使用next方法来调用值

生成式和函数放在一起使用，有奇效。

### 8. 函数的递归调用

实质上是函数嵌套调用的一种特殊形式，具体指的是，在调用一个函数的过程中直接或者间接地调用到函数本身，其本质就是循环。

需要注意，死循环不占内存，但是递归调用占内存。因此，递归不应该无限的调用下去，必须在满足条件地情况下结束递归调用。

**递归的两个阶段：**

1. 回溯：一层一层调用下去。
2. 递推：满足某种结束条件，结束递归调用，然后一层层返回。

递归的返回值推算需要从最后一层开始推。

**递归的应用：**

1. 
2. 二分法