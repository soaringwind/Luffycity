# 并发编程

## 操作系统发展史

计算机，也称为电脑，即通电的大脑，发明计算机的目的是为了让电脑像人一样工作，不仅可以每天二十四小时工作，而且效率高。

计算机的五大组成部分：

1. 控制器
2. 运算器和控制器一起，组成CPU
3. 存储器
4. 输入设备
5. 输出设备

程序的运行，需要先由硬盘读到内存，之后CPU来读取内存来执行。

## 多道技术

定义：允许多个程序同时进入内存并运行，即同时把多个程序放入内存，并允许它们交替在CPU中运行，它们共享系统中的各种软、硬资源，且当一道程序由于I/O请求而暂停运行的时候，CPU便立即转去运行另一道程序。

目的：单核实现并发的效果。

![img](https://images2017.cnblogs.com/blog/827651/201801/827651-20180110183621582-153745188.png)

![img](https://images2017.cnblogs.com/blog/827651/201801/827651-20180110183714426-287499114.png)



并发：只要看起来像同时运行的就可以称之为并发。

并行：真正意义上的同时执行。

PS：并行肯定是并发，单核计算机肯定不能实现并行，但是可以实现并发！！！

PPS：单核指的是只有一个核，即干活的只有一个人。

### 多道技术的重点知识：

空间上的复用与时间上的复用

1. 空间上的复用
   - 多个程序公用一套计算机硬件
2. 时间上的复用
   - 单道：计算全部时间的和
   - 多道：最长的那个时间，切换+保存状态

切换CPU的两种情况：

1. 当一个程序遇到IO操作时，操作系统会剥夺该程序的CPU执行权限。
   - 作用：提高CPU利用率，不影响效率。
2. 当一个程序长时间占用CPU时，操作系统也会剥夺程序的CPU执行权限
   - 作用：降低了程序的执行效率（原本时间+切换时间）

## 进程

定义：计算机中的程序关于某数据集合上的一次运行活动，是系统进行资源分配和调用的基本单位，是操作系统结构的基础。

### 程序与进程的区别

程序是一堆躺在硬盘上的代码，是“死”的。

进程则表示程序正在执行的过程，是“活”的。

### 进程调度

#### 先来先服务调度算法

FCFS调度算法：一种最简单的调度算法，有利于长作业，不利于短作业。

#### 短作业优先调度算法

SJ/PF调度算法：对短作业或短进程进行优先调度，对短工作有利，对长作业不利。

#### 时间片轮转法+多级反馈队列

将CPU分为三个等级，越往下说明任务需要的时间越长，越往下任务执行的优先级越低。当一个队列中出现新的任务，那么CPU会立刻停止当前执行的任务，去执行新添加进来的第一层队列中的任务。

### 进程执行的三状态图

![img](https://images2017.cnblogs.com/blog/827651/201801/827651-20180110201327535-1120359184.png)

![img](https://images2017.cnblogs.com/blog/827651/201801/827651-20180110204322676-135915799.png)

在实际程序运行的过程中，由于被操作系统的调度算法控制，程序会进入几个状态：就绪、运行和堵塞。

就绪（Ready）状态

当进程已分配到除CPU以外的所有必要资源，只要获得处理机会便立即执行，这时的进程状态称为就绪状态。

执行/运行（Running）状态

当进程已获得处理机会，其程序正在处理机上执行，此时的进程称为执行状态。

阻塞（Blocked）状态

正在执行的进程，由于等待某个事件发生而无法执行时，便放弃处理机而处于阻塞状态。

### 同步和异步

这两者描述的是任务的提交方式。

同步：任务提交之后，原地等待任务的返回结果，啥事不干（干等）。

异步：任务提交之后，不原地等待，直接去做其他事情，等待任务的返回结果。

提交的任务结果如何获取？

任务的返回直接会有一个异步回调机制自动处理。

### 阻塞与非阻塞

这两者描述的是程序的状态。

阻塞：阻塞态。

非阻塞：就绪态、运行态。

理想状态：写的代码永远处于就绪态和运行态之间切换。

最高效的组合：异步非阻塞。

## 开启进程的两种方式

注意：

windows操作系统下，创建进程一定要在main内创建，因为windows下创建进程类似于模块导入的方式，会从上而下的执行代码，如果写在main外会导致死循环。

Linux则类似于copy一份，没关系。

两种代码

``` python
from multiprocessing import Process

def task(n):
    print(1)
    print(n)
    print(2)
    
    
# 1. 创建对象
p = Process(target=task, args=('egon', ))  # 注意：这里传参必须使用元组格式，且必须加逗号
# 2. 开启进程
p.start()  # 告诉操作系统，帮你创建一个进程，异步
print('主')
```

```python 
from mulitprocessing import Process

class MyProcess(Process):
    def run(self):
        print(123)
        print(321)

if __name__ = '__main__':
    p = MyProcess()
    p.start()
```

总结：

1. 创建进程就是在内存中申请一块内存空间，将需要运行的代码丢进去。
2. 一个进程对应在内存中就是一块独立的内存空间。
3. 多个进程对应在内存中就是多块独立的内存空间。
4. 进程与进程之间默认情况下无法进行交互，如果非要进行，需要借助第三方模块。

### join方法

join：让主进程等待子进程p运行结束后，再继续往后执行，先全开，后面再等待。

### 进程间数据隔离

无法修改到进程外的数据。

## 人工智能

http://www.turingapi.com/

https://market.baidu.com/api

## 进程对象及其他方法

p.pid：进程的pid号。

计算机会给每一个运行的进程分配一个PID号，用来区分并管理这些进程服务端。

windows: cmd + tasklist | findstr pid

mac: ps aux | grep pid

```python
from multiprocessing import Process, current_process

def task():
    print('pid is %s' % current_process().pid)
    
if __name__ == '__main__':
    p = Process(target=task)
    p.start()
```

```python
import os

def task():
    print('pid is %s' % os.getpid())  # 获取子进程pid号
    print('父pid is %s' % os.getppid())  # 获取父进程pid号
```











