# 第三模块 面向对象编程

## 面向过程

核心：“过程”二字，过程指的是解决问题的步骤，通过设计一条流水线来解决问题，一种机械式的思维方式。

优点：复杂的问题流程化，进而简单化。

缺点：可扩展性差。

## 面向对象

核心：“对象”二字，对象的精髓就在于将程序“整合”，对象的本质就是“容器”，用来盛放数据和功能。

优点：扩展性强

程序  = 数据 + 功能，因此编写程序的本质就是定义出一系列的数据，然后定义出一系列的功能来对数据进行操作。

### 类与对象

#### 类的定义与实例化

在人类世界一定先有对象，再分类，而在程序中，一定要先定义类再使用类来实例化出一个对象。类，同样是一个容器，它用来把同一类对象的相同数据与功能存放到类里，而不需要每个对象都重复存一份，每个单独的对象只需要存放自己独有的数据即可，解决了代码冗余的问题。

![image-20200804150835550](C:\Users\soaringwind\AppData\Roaming\Typora\typora-user-images\image-20200804150835550.png)

类体代码规范：

- 类名必须使用驼峰体。

- 类体中最常见的是变量的定义和函数的定义，但类体实际上可以包含任何代码，且类体代码在定义阶段就会执行，因此会产生新的名称空间来存放类中定义的名字，通过```Class.__dict__```可以查看类中的名称空间。
- 类中共有的数据可以直接通过在类体代码中定义变量来获得，而如果想要定制独有的数据，一种是通过``__init__``方法来为对象进行初始化操作，第二种通过对象的**增删改查操作**自行添加来定制独有数据。

调用类的过程称为实例化过程，调用类之后得到的返回值就是对象，或称为一个实例。

总结```__init__```方法：

1. 在调用类时会自动触发执行，用来为对象进行初始化自已独有的数据。
2. ```__init__```内应该存放的是为对象初始化属性的功能，但是实际上可以存放任意其他的代码，所有想要在类调用时就执行的代码都可以放到该方法里去。
3. ```__init__```的代码中存放的数据类型应该都为属性值，self.attribute或Class.attribute格式，而不应该出现直接的变量名。注意：无法访问到外部变量，只能访问属性值。
4. ```__init__```方法的返回值必须是None。

总结实例化对象时发生的三件事：

1. 通过调用类，实例化一个空对象。
2. 根据```__init__```方法添加属性，进行初始化操作。
3. 返回初始化完的对象。

#### 属性访问

类属性：在类中定义的属性，都是类属性，可分为两种属性，数据属性和函数属性，可以通过```__dict__```来访问属性及属性值。

##### 属性查找顺序与绑定方法

对象的名称空间只存放着对象独有的属性，而对象们共有的属性存放在类中。对象在访问属性时，会优先从对象本身的```__dict__```中查找，未找到，则去类的```__dict___```中查找，类似于函数的局部变量与全局变量关系。

1. 类中定义的变量是类的数据属性，是共享给所有对象用的，指向相同的内存地址。如果想要改变所有类中的数据，则需要使用Class.attribute来改变。

2. 类中定义的函数是类的函数属性，类可以使用，但是必须遵循函数的传参规则，有多少参数就传入多少参数。

   在实际运行过程中，类中定义的函数是绑定给对象使用的，虽然所有对象指向的都是相同的功能，但是绑定不同的对象就是不同的绑定方法，内存地址各不相同。

   绑定到对象的方法特殊之处就在于，绑定给谁就应该由谁来调用，谁来调用，函数就会将谁本身当做第一个参数自动传入，也就是self的作用。

##### 属性的增删改查

增：Class.name = 'alex'，相当于```Class.__dict__['name'] = 'alex'```，添加函数也可以。

删：del Class.name

改：Class.name = 'jack'

查：Class.name

*在类中定义的函数第一个参数是self，如果直接调用class()则必须传入self参数，但是class.func()中第一个self不需要传入参数，因为会默认传入调用函数的对象。*

小作业：

```python
# 编写一个学生类，产生一堆学生对象
# 1. 有一个计数器（属性），统计总共实例了多少个对象
class LuffyStudent:
    school = 'LuffyCity'
    count = 0
    def __init__(self, name, age, sex):
        self.name = name
        self.age = age
        self.sex = sex
        LuffyStudent.count += 1
    def eat(self):
        print('%s is eating' % self.name)
    def sleep(self):
        print('%s is sleeping' % self.name)

stu1 = LuffyStudent('alex', 18, 'Male')
sut2 = LuffyStudent('jack', 29, 'Male')
stu3 = LuffyStudent('Liz', 24, 'Female')
print(LuffyStudent.count)
```

```python
# 模仿王者荣耀定义两个英雄类
# 英雄需要有昵称、攻击力、生命值等属性；
# 实例化出两个英雄对象；
# 英雄之间可以互殴，被殴打的一方掉血，血量小于0则判定为死亡。
class TankHero:
    def __init__(self, name, attack_val, blood):
        self.name = name
        self.attack_val = attack_val
        self.blood = blood
    def attack(self, obj):
        obj.blood -= self.attack_val
        if obj.blood > 0:
        	print(f'{self.name} attack {obj.name}, {obj.name} has {obj.blood} blood')
        else:
            print(f'{obj.name} is dead')

class ArcherHero:
    def __init__(self, name, attack_val, blood):
        self.name = name
        self.attack_val = attack_val
        self.blood = blood
    def attack(self, obj):
        import random
        if random.randint(1, 6) != 5:
        	obj.blood -= self.attack_val
        if obj.blood > 0:
            print(f'{self.name} attack {obj.name}, {obj.name} has {obj.blood} blood')
        else:
            print(f'{obj.name} is dead')
Dema = TankHero('Dema', 20, 120)
Ice = ArcherHero('Ice', 40, 100)
Dema.attack(Ice)
Ice.attack(Dema)
Dema.attack(Ice)
Ice.attack(Dema)
```

### 三大特性

#### 封装

封装指的是将数据与功能都整合到一起，可以分为两步：隐藏与开放接口。

##### 隐藏操作

通过在属性名前加上__前缀，就会实现一个对外隐藏属性的效果。

```python
class Foo:
    __x = 1
    def __f1(self):
        print('hello, world!')
    def f2(self):
        __f1()
```

注意：

1. 这种操作只是语法上的变形，通过```_Foo__x```同样能访问到，但是没有意义。
2. 对外不对内，内部通过self.__attribute可以访问到，这是因为在类定义阶段时，会统一发生变形。
3. 变形只在类定义的时候发生一次，在定义之后的__开头的属性，不会发生变形，即增加属性不会变形。

为何要隐藏？

1. 隐藏数据属性（不允许直接查看）：通过使用函数（开放接口）来进行间接访问，也就是加上附加条件。
2. 隐藏函数属性：隔离复杂度，用户不需要知道有多少函数。

总结：

隐藏属性和开放接口，本质上就是为了明确区分内外，设计者可以修改封装内的东西而不影响外部调用者的代码。同时，类外部只需要拿到设计者提供的开放接口，只要接口名和参数不变，那么无论内部代码怎么修改，调用者均不需要改变代码。