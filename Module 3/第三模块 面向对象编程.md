# 第三模块 面向对象编程

## 面向过程

核心：“过程”二字，过程指的是解决问题的步骤，通过设计一条流水线来解决问题，一种机械式的思维方式。

优点：复杂的问题流程化，进而简单化。

缺点：可扩展性差。

## 面向对象

核心：“对象”二字，对象的精髓就在于将程序“整合”（封装），对象的本质就是“容器”，用来盛放数据和功能。

优点：扩展性强

程序  = 数据 + 功能，因此编写程序的本质就是定义出一系列的数据，然后定义出一系列的功能来对数据进行操作。

### 类与对象

#### 类的定义与实例化

在人类世界一定先有对象，再分类，而在程序中，一定要先定义类再使用类来实例化出一个对象。类，同样是一个容器，它用来把同一类对象的相同数据与功能存放到类里，而不需要每个对象都重复存一份，每个单独的对象只需要存放自己独有的数据即可，解决了代码冗余的问题。

![image-20200804150835550](C:\Users\soaringwind\AppData\Roaming\Typora\typora-user-images\image-20200804150835550.png)

类体代码规范：

- 类名必须使用驼峰体。

- 类体中最常见的是变量的定义和函数的定义，但类体实际上可以包含任何代码，且类体代码在定义阶段就会执行（即使没有调用产生对象，也会执行），因此会产生新的名称空间来存放类中定义的名字，通过```Class.__dict__```可以查看类中的名称空间。
- 类中共有的数据可以直接通过在类体代码中定义变量来获得，而如果想要定制独有的数据，一种是通过``__init__``方法来为对象进行初始化操作，第二种通过对象的**增删改查操作**自行添加来定制独有数据。

调用类的过程称为实例化过程，调用类之后得到的返回值就是对象，或称为一个实例。

总结```__init__```方法：

1. 在调用类时会自动触发执行，用来为对象进行初始化自已独有的数据。
2. ```__init__```内应该存放的是为对象初始化属性的功能，但是实际上可以存放任意其他的代码，所有想要在类调用时就执行的代码都可以放到该方法里去（例如计数）。
3. ```__init__```的代码中存放的数据类型应该都为属性值，self.attribute或Class.attribute格式，而不应该出现直接的变量名。注意：无法访问到外部变量，只能访问属性值。
4. ```__init__```方法的返回值必须是None。

总结实例化对象时发生的三件事：

1. 通过调用类，实例化一个空对象。
2. 根据```__init__```方法添加属性，进行初始化操作。
3. 返回初始化完的对象。

#### 属性访问

类属性：在类中定义的属性，都是类属性，可分为两种属性，数据属性和函数属性，可以通过```__dict__```来访问属性及属性值。

##### 属性查找顺序与绑定方法

对象的名称空间只存放着对象独有的属性，而对象们共有的属性存放在类中。对象在访问属性时，会优先从对象本身的```__dict__```中查找，未找到，则去类的```__dict___```中查找，类似于函数的局部变量与全局变量关系。通过调用mro()方法可以确定属性查找顺序，python3之后。

1. 类中定义的变量是类的数据属性，是共享给所有对象用的，指向相同的内存地址。如果想要改变所有类中的数据，则需要使用Class.attribute来改变。

2. 类中定义的函数是类的函数属性，类本身可以使用，但是必须遵循函数的传参规则，有多少参数就传入多少参数（即需要传入self参数）。后续，使用@classmethod装饰器可以使得类绑定函数，不需要再自己传入自己。

在实际运行过程中，类中定义的函数是绑定给对象使用的，虽然所有对象指向的都是相同的功能，但是绑定不同的对象就是不同的绑定方法，内存地址各不相同。

绑定到对象的方法特殊之处就在于，绑定给谁就应该由谁来调用，谁来调用，函数就会将谁本身当做第一个参数自动传入，也就是self的作用。

##### 属性的增删改查

增：Class.name = 'alex'，相当于```Class.__dict__['name'] = 'alex'```，添加函数也可以。

删：del Class.name

改：Class.name = 'jack'

查：Class.name

*在类中定义的函数第一个参数是self，如果直接调用类Class()则必须传入self参数，但是对象Class.func()中第一个self不需要传入参数，因为会默认传入调用函数的对象。*

小作业：

```python
# 编写一个学生类，产生一堆学生对象
# 1. 有一个计数器（属性），统计总共实例了多少个对象
class LuffyStudent:
    school = 'LuffyCity'
    count = 0
    def __init__(self, name, age, sex):
        self.name = name
        self.age = age
        self.sex = sex
        LuffyStudent.count += 1
    def eat(self):
        print('%s is eating' % self.name)
    def sleep(self):
        print('%s is sleeping' % self.name)

stu1 = LuffyStudent('alex', 18, 'Male')
sut2 = LuffyStudent('jack', 29, 'Male')
stu3 = LuffyStudent('Liz', 24, 'Female')
print(LuffyStudent.count)
```

```python
# 模仿王者荣耀定义两个英雄类
# 英雄需要有昵称、攻击力、生命值等属性；
# 实例化出两个英雄对象；
# 英雄之间可以互殴，被殴打的一方掉血，血量小于0则判定为死亡。
class TankHero:
    def __init__(self, name, attack_val, blood):
        self.name = name
        self.attack_val = attack_val
        self.blood = blood
    def attack(self, obj):
        obj.blood -= self.attack_val
        if obj.blood > 0:
        	print(f'{self.name} attack {obj.name}, {obj.name} has {obj.blood} blood')
        else:
            print(f'{obj.name} is dead')

class ArcherHero:
    def __init__(self, name, attack_val, blood):
        self.name = name
        self.attack_val = attack_val
        self.blood = blood
    def attack(self, obj):
        import random
        if random.randint(1, 6) != 5:
        	obj.blood -= self.attack_val
        if obj.blood > 0:
            print(f'{self.name} attack {obj.name}, {obj.name} has {obj.blood} blood')
        else:
            print(f'{obj.name} is dead')
Dema = TankHero('Dema', 20, 120)
Ice = ArcherHero('Ice', 40, 100)
Dema.attack(Ice)
Ice.attack(Dema)
Dema.attack(Ice)
Ice.attack(Dema)
```

### 三大特性

#### 封装

封装指的是将数据与功能都整合到一起，可以分为两步：隐藏与开放接口。

##### 隐藏操作

通过在属性名前加上__前缀，就会实现一个对外隐藏属性的效果。

需要记住，隐藏不是目的，如何使用才是目的。

```python
class Foo:
    __x = 1
    def __f1(self):
        print('hello, world!')
    def f2(self):
        __f1()
```

注意：

1. 这种操作只是语法上的变形，通过```_Foo__x```同样能访问到，但是没有意义。
2. 对外不对内，内部通过self.__attribute可以访问到，这是因为在类定义阶段时，会统一发生变形。
3. 变形只在类定义的时候发生一次，在定义之后的__开头的属性，不会发生变形，即增加属性不会变形。

为何要隐藏？

1. 隐藏数据属性（不允许直接查看）：通过使用函数（开放接口）来进行间接访问，也就是加上附加条件。
2. 隐藏函数属性：隔离复杂度，用户不需要知道有多少函数。

总结：隐藏属性和开放接口，本质上就是为了明确区分内外，设计者可以修改封装内的东西而不影响外部调用者的代码。同时，类外部只需要拿到设计者提供的开放接口，只要接口名和参数不变，那么无论内部代码怎么修改，调用者均不需要改变代码。

##### property

property就是一个装饰器，它是将绑定给对象的函数属性变成对象的数据属性，即在调用时，可以直接使用Class.attribute来得到返回值，而不需要加括号调用。

```python
class People(object):
    def __init__(self, name, weight, height):
        self.name = name
        self.weight = weight
        self.height = height
    def bmi(self):
        self.bmi = self.weight / (self.height ** 2)  # 不好，还是直接返回值，不要添加属性。
        return self.bmi  # 这里就变成自己调用自己，写的什么玩意儿。
peo1 = People('alex', 70, 1.70)
print(peo1.bmi())
peo1.height = 1.80  # 这里的修改height，但是bmi不会随着修改。
print(peo1.bmi())  # 这个位置不能加括号调用，因为前一个对象已经将bmi当做数据属性。这里写的就不对，不要看。应该直接return表达式。



class People(object):
    def __init__(self, name, weight, height):
        self.name = name
        self.weight = weight
        self.height = height
    @property
    def bmi(self):
        return self.weight / (self.height ** 2)
peo1 = People('alex', 70, 1.70)
print(peo1.bmi)
peo1.height = 1.80
print(peo1.bmi)
```

property其他用法：

property提供对属性进行设置和删除功能，先使用老办法。

```python
class People(object):
    def __init__(self, name):
        self.name = name
    
    def get_name(self):
        print(self.name)
    
    def set_name(self, new_name):
        if isinstance(new_name, str):
            self.name = new_name
        else:
            return
    
    def del_name(self):
        print('you can not delete name.')
	name11 = property(get_name, set_name, del_name)  # 这里需要注意，笨办法的名字（name11）不能和里面的(name)重复，否则会一直变成递归。
peo1 = People('alex')
peo1.name11
```

新办法：

```python
class People(object):
    def __init__(self, name):
        self.name = name
    @property
    def name(self):
        print(self.name)
    @name.setter
    def name(self, val):
        if isinstance(val, str):
            self.name = val
        else:
            print('please check the input')
    @name.deleter
    def name(self):
        print('you can not delete name')

peo1 = People('alex')
peo1.name
peo1.name(1212)
del peo1.name
```

#### 继承与派生

继承实际上是一种创建新类的方法，新建的类称之为子类或派生类，父类称之为基类或超类。其中，子类会遗传父类的所有属性。因此，在设计中，父类应该是最上面，最统一的功能。

注意：python2中分为经典类和新式类，而python3中全部为新式类，默认继承object。

python的多继承：

优点：子类可以同时遗传多个父类的属性，在最大限度上地重用代码。

缺点：

1. 违背人的思维：继承表达的是一种什么“是”什么的关系，而指向多个，容易混乱。
2. 代码的可读性变差。
3. 扩展性变差，因此不建议使用多继承，即使真的要使用，也应该使用Mixins机制。

##### 单继承的属性查找问题

仔细按照定义的规则来找，不要凭借眼中的就近原则，如果很想要来调用自己推荐使用隐藏属性的方式来调用。

##### 多继承的属性查找问题

C3算法，使用Class.mro()得到的MRO列表来判断顺序，经典类没有这个列表。

经典类的查找顺序是深度优先，第一次就会走到头。

##### Mixins机制

多继承的正确打开方式：Mixins机制

核心：在多继承背景下尽可能地提升多继承的可读性，并且让多继承满足人的思维习惯，什么是什么。

```python
class Vehicle(object):
    pass
class FlyableMixins(object):
    def fly(self):
        print('flying....')
class CivilAircraft(FlyableMixins, Vehicle):
    pass
class Helicopter(FlyableMixins, Vehicle):
    pass
```

注意：

1. Mixin类，一般以Mixin，able，ible为后缀，用来表示某一种功能（会飞的），而不是表达物品属性。
2. 有多个Mixin的情况下，每个Mixin的责任必须单一，只能有一个父亲。
3. Mixin尽量独立，不依赖于子类存在。
4. 子类可以没有Mixins，也可以存在，只是会少了某个功能。

##### 派生

子类可以派生出自己新的属性，在进行属性查找时，子类中的属性名会优先于父类被查找。

两种方法：

1. 指名道姓地调用某一个类下的函数，不依赖于继承关系。只要你有，我就可以拿来并覆盖。
2. super()方法调用父类提供给自己的方法，严格依赖继承关系。

两种方法都可以使用，python3推荐使用super()，但是千万不要混着用，记住属性查找顺序，一定是按照属性查找发起者的MRO来往下查找，而不能往上找。

```python
class People(object):
    def __init__(self, name, age, gender):
        self.name = name
        self.age = age
        self.gender = gender
class Teacher(People):
    def __init__(self, name, age, gender, salary):
        super().__init__(name, age, gender)
        self.salary = salary
tea1 = Teacher('alex', 29, 'male', 29999)
```



#### 组合

在一个类中以另外一个类的对象作为数据属性，称为类的组合。例如，课表使用列表来进行添加课程。

```python
# 尝试给英雄组合武器
```



#### 多态性与鸭子类型

多态指的是一类事物有多种形态，比如动物有猫、狗、猪。

多态性指的是可以在不用考虑对象具体类型的情况下，直接使用对象，这就需要在设计时，把对象的使用方法统一成一种。

```python
class Animal(object):
    def talk(self):
        print('can say')
class Duck(Animal):
    def talk(self):
        super().talk()    # super放到相应的函数里面
        print('yayaya')
class Chicken(Animal):
    def talk(self):
        super().talk()
        print('jijiji')
        
def talk(obj):
    obj.talk()   # 使用统一接口来使用，len之类的
```

多态性的本质在于，不同的类中定义有相同的方法名，这样我们就可以不用考虑类而统一使用一种方式来使用对象。

python提倡鸭子类型，即只要有相同的外观和行为即可，不需要有继承关系，长得像就完事了。

抽象类方法，给父类中的某一函数加上@abc.abstractmethod装饰器，使得如果有子类继承则必须有该函数。

### 绑定方法与非绑定方法

类中定义的函数分为两个大类：绑定方法和非绑定方法。

#### 绑定方法

1. 绑定到对象的方法：在类中定义的函数，默认绑定到对象上。
2. 绑定到类的方法：在定义函数时，加上@classmethod装饰器，则绑定到类上。专门给类使用，会自动讲类传入到第一个参数。

绑定到类的方法通常用来在```__init___```的基础上提供一种额外的初始化实例的方式。

#### 非绑定方法

在类中给某个函数加上@staticmethod装饰器之后，该函数就变成非绑定方法，也成为静态方法。该函数变成普通函数，调用需要传入所有参数，不会自动传值，即说明该方法无需引用类或对象。

```python
import uuid
class Teacher(object):
    def __init__(self, name, age):
        self.id = create_id()  # 该方法希望在每生成一个对象时都调用。
        self.name = name
        self.age = age
    @staticmethod
    def create_id():
        return uuid.uuid1()
```

