# 第三模块 面向对象编程

## 面向过程

核心：“过程”二字，过程指的是解决问题的步骤，通过设计一条流水线来解决问题，一种机械式的思维方式。

优点：复杂的问题流程化，进而简单化。

缺点：可扩展性差。

## 面向对象

核心：“对象”二字，对象的精髓就在于将程序“整合”（封装），对象的本质就是“容器”，用来盛放数据和功能。

优点：扩展性强

程序  = 数据 + 功能，因此编写程序的本质就是定义出一系列的数据，然后定义出一系列的功能来对数据进行操作。

### 类与对象

#### 类的定义与实例化

在人类世界一定先有对象，再分类，而在程序中，一定要先定义类再使用类来实例化出一个对象。类，同样是一个容器，它用来把同一类对象的相同数据与功能存放到类里，而不需要每个对象都重复存一份，每个单独的对象只需要存放自己独有的数据即可，解决了代码冗余的问题。

![image-20200804150835550](C:\Users\soaringwind\AppData\Roaming\Typora\typora-user-images\image-20200804150835550.png)

类体代码规范：

- 类名必须使用驼峰体。

- 类体中最常见的是变量的定义和函数的定义，但类体实际上可以包含任何代码，且类体代码在定义阶段就会执行（即使没有调用产生对象，也会执行），因此会产生新的名称空间来存放类中定义的名字，通过```Class.__dict__```可以查看类中的名称空间。
- 类中共有的数据可以直接通过在类体代码中定义变量来获得，而如果想要定制独有的数据，一种是通过``__init__``方法来为对象进行初始化操作，第二种通过对象的**增删改查操作**自行添加来定制独有数据。

调用类的过程称为实例化过程，调用类之后得到的返回值就是对象，或称为一个实例。

总结```__init__```方法：

1. 在调用类时会自动触发执行，用来为对象进行初始化自已独有的数据。
2. ```__init__```内应该存放的是为对象初始化属性的功能，但是实际上可以存放任意其他的代码，所有想要在类调用时就执行的代码都可以放到该方法里去（例如计数）。
3. ```__init__```的代码中存放的数据类型应该都为属性值，self.attribute或Class.attribute格式，而不应该出现直接的变量名。注意：无法访问到外部变量，只能访问属性值。
4. ```__init__```方法的返回值必须是None。

总结实例化对象时发生的三件事：

1. 通过调用类，实例化一个空对象。
2. 根据```__init__```方法添加属性，进行初始化操作。
3. 返回初始化完的对象。

#### 属性访问

类属性：在类中定义的属性，都是类属性，可分为两种属性，数据属性和函数属性，可以通过```__dict__```来访问属性及属性值。

##### 属性查找顺序与绑定方法

对象的名称空间只存放着对象独有的属性，而对象们共有的属性存放在类中。对象在访问属性时，会优先从对象本身的```__dict__```中查找，未找到，则去类的```__dict___```中查找，类似于函数的局部变量与全局变量关系。

1. 类中定义的变量是类的数据属性，是共享给所有对象用的，指向相同的内存地址。如果想要改变所有类中的数据，则需要使用Class.attribute来改变。

2. 类中定义的函数是类的函数属性，类本身可以使用，但是必须遵循函数的传参规则，有多少参数就传入多少参数（即需要传入self参数）。

在实际运行过程中，类中定义的函数是绑定给对象使用的，虽然所有对象指向的都是相同的功能，但是绑定不同的对象就是不同的绑定方法，内存地址各不相同。

绑定到对象的方法特殊之处就在于，绑定给谁就应该由谁来调用，谁来调用，函数就会将谁本身当做第一个参数自动传入，也就是self的作用。

##### 属性的增删改查

增：Class.name = 'alex'，相当于```Class.__dict__['name'] = 'alex'```，添加函数也可以。

删：del Class.name

改：Class.name = 'jack'

查：Class.name

*在类中定义的函数第一个参数是self，如果直接调用类Class()则必须传入self参数，但是对象Class.func()中第一个self不需要传入参数，因为会默认传入调用函数的对象。*

小作业：

```python
# 编写一个学生类，产生一堆学生对象
# 1. 有一个计数器（属性），统计总共实例了多少个对象
class LuffyStudent:
    school = 'LuffyCity'
    count = 0
    def __init__(self, name, age, sex):
        self.name = name
        self.age = age
        self.sex = sex
        LuffyStudent.count += 1
    def eat(self):
        print('%s is eating' % self.name)
    def sleep(self):
        print('%s is sleeping' % self.name)

stu1 = LuffyStudent('alex', 18, 'Male')
sut2 = LuffyStudent('jack', 29, 'Male')
stu3 = LuffyStudent('Liz', 24, 'Female')
print(LuffyStudent.count)
```

```python
# 模仿王者荣耀定义两个英雄类
# 英雄需要有昵称、攻击力、生命值等属性；
# 实例化出两个英雄对象；
# 英雄之间可以互殴，被殴打的一方掉血，血量小于0则判定为死亡。
class TankHero:
    def __init__(self, name, attack_val, blood):
        self.name = name
        self.attack_val = attack_val
        self.blood = blood
    def attack(self, obj):
        obj.blood -= self.attack_val
        if obj.blood > 0:
        	print(f'{self.name} attack {obj.name}, {obj.name} has {obj.blood} blood')
        else:
            print(f'{obj.name} is dead')

class ArcherHero:
    def __init__(self, name, attack_val, blood):
        self.name = name
        self.attack_val = attack_val
        self.blood = blood
    def attack(self, obj):
        import random
        if random.randint(1, 6) != 5:
        	obj.blood -= self.attack_val
        if obj.blood > 0:
            print(f'{self.name} attack {obj.name}, {obj.name} has {obj.blood} blood')
        else:
            print(f'{obj.name} is dead')
Dema = TankHero('Dema', 20, 120)
Ice = ArcherHero('Ice', 40, 100)
Dema.attack(Ice)
Ice.attack(Dema)
Dema.attack(Ice)
Ice.attack(Dema)
```

### 三大特性

#### 封装

封装指的是将数据与功能都整合到一起，可以分为两步：隐藏与开放接口。

##### 隐藏操作

通过在属性名前加上__前缀，就会实现一个对外隐藏属性的效果。

```python
class Foo:
    __x = 1
    def __f1(self):
        print('hello, world!')
    def f2(self):
        __f1()
```

注意：

1. 这种操作只是语法上的变形，通过```_Foo__x```同样能访问到，但是没有意义。
2. 对外不对内，内部通过self.__attribute可以访问到，这是因为在类定义阶段时，会统一发生变形。
3. 变形只在类定义的时候发生一次，在定义之后的__开头的属性，不会发生变形，即增加属性不会变形。

为何要隐藏？

1. 隐藏数据属性（不允许直接查看）：通过使用函数（开放接口）来进行间接访问，也就是加上附加条件。
2. 隐藏函数属性：隔离复杂度，用户不需要知道有多少函数。

总结：隐藏属性和开放接口，本质上就是为了明确区分内外，设计者可以修改封装内的东西而不影响外部调用者的代码。同时，类外部只需要拿到设计者提供的开放接口，只要接口名和参数不变，那么无论内部代码怎么修改，调用者均不需要改变代码。

##### property

property就是一个装饰器，它是将绑定给对象的函数属性变成对象的数据属性，即在调用时，可以直接使用Class.attribute来得到返回值，而不需要加括号调用。

```python
class People(object):
    def __init__(self, name, weight, height):
        self.name = name
        self.weight = weight
        self.height = height
    def bmi(self):
        self.bmi = self.weight / (self.height ** 2)  # 不好，还是直接返回值，不要添加属性。
        return self.bmi
peo1 = People('alex', 70, 1.70)
print(peo1.bmi())
peo1.height = 1.80  # 这里的修改height，但是bmi不会随着修改。
print(peo1.bmi)  # 这个位置不能加括号调用，因为前一个对象已经将bmi当做数据属性。



class People(object):
    def __init__(self, name, weight, height):
        self.name = name
        self.weight = weight
        self.height = height
    @property
    def bmi(self):
        return self.weight / (self.height ** 2)
peo1 = People('alex', 70, 1.70)
print(peo1.bmi)
peo1.height = 1.80
print(peo1.bmi)
```

property其他用法：

property提供对属性进行设置和删除功能，先使用老办法。

```python
class People(object):
    def __init__(self, name):
        self.name = name
    
    def get_name(self):
        print(self.name)
    
    def set_name(self, new_name):
        if isinstance(new_name, str):
            self.name = new_name
        else:
            return
    
    def del_name(self):
        print('you can not delete name.')
	name11 = property(get_name, set_name, del_name)  # 这里需要注意，笨办法的名字不能和里面的名重复，否则会一直变成递归。
peo1 = People('alex')
peo1.name11
```

新办法：

```python
class People(object):
    def __init__(self, name):
        self.name = name
    @property
    def name(self):
        print(self.name)
    @name.setter
    def name(self, val):
        if isinstance(val, str):
            self.name = val
        else:
            print('please check the input')
    @name.deleter
    def name(self):
        print('you can not delete name')

peo1 = People('alex')
peo1.name
peo1.name(1212)
del peo1.name
```

#### 继承

继承实际上是一种创建新类的方法，新建的类称之为子类或派生类，父类称之为基类或超类。其中，子类会遗传父类的所有属性。因此，在设计中，父类应该是最上面，最统一的功能。

注意：python2中分为经典类和新式类，而python3中全部为新式类，默认继承object。

python的多继承：

优点：子类可以同时遗传多个父类的属性，在最大限度上地重用代码。

缺点：

1. 违背人的思维：继承表达的是一种什么“是”什么的关系，而指向多个，容易混乱。
2. 代码的可读性变差。
3. 扩展性变差，因此不建议使用多继承，即使真的要使用，也应该使用Mixins机制。

##### 单继承的属性查找问题

仔细按照定义的规则来找，不要凭借眼中的就近原则，如果很想要来调用自己推荐使用隐藏属性的方式来调用。

##### 多继承的属性查找问题

C3算法，使用Class.mro()得到的MRO列表来判断顺序，经典类没有这个列表。

经典类的查找顺序是深度优先，第一次就会走到头。