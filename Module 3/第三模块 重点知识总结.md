# 第三模块 重点知识总结

## 面向对象编程

### 面向对象的三大特性

#### 继承

减少代码冗余，保证了一个什么是什么的关系，但是会带来属性查找的问题。python3默认为新式类，继承object。

##### 派生

派生就是通过重新写方法，生成的对象，要有自己的新东西。

##### 重写父类方法

1. 指名道姓，重写什么方法，就使用父类名+父类方法名，然后把新的写进去。不依赖继承关系。
2. super()：python3中super()等同于super(父类, self)。依赖继承关系。

##### 组合

继承表达的是什么是什么，组合表达的是什么有什么。现在很多人喜欢用组合，而不用继承。

##### 抽象类

定义：一种特殊的类，只能被继承，不能被实例化。抽象类中只能有抽象方法（不会实现功能），且派生出的子类必须有该方法。简直就是多态。

实现方法：导入abc模块，abc.abstractmethod

#### 封装

通过提供接口的方式，把简陋和复杂的内容隐藏起来，让用户调用十分简单，主要分为两步，隐藏和开放。

目的：隔离复杂度。

特点：明确区分内外，使得类实现者可以修改封装内的东西而不影响外部调用者的代买，而外部使用者，只需要知道有一个接口，接口不变，参数不变即可，使用者的代码永远不需改变。

##### 隐藏

定义：在python中用双下划线开头的方式将属性隐藏起来（设置成私有的）。

使用：在类的定义阶段，隐藏会发生变形。

特点：

```python
# 1. 类中定义的双下划线开头的属性，只能在内部使用。

# 2. 这种变形针对的是外部变形，在外部无法通过双下划线开头的属性来访问，但内部可以。

# 3. 在子类定义的双下划线开头的属性不会覆盖父类定义的双下划线属性。
```

##### 开放接口

将数据隐藏不是目的，隐藏起来然后对外提供操作该数据的接口，从而达到对数据属性操作的严格控制。

#### 多态

在使用时不需要关心不同类的多种形态，只需要知道有某个方法，可以统一的去调用。

定义：一种事物有多种形态。

多态性：在不考虑实例类型的情况下使用实例，多态性分为静态多态性和动态多态性。

### 属性查找

如果对象有，直接用对象的，如果对象没有，再去找类以及父类的，通过调用mro方法，可以查看到属性查找的顺序。

#### 类属性

类有两种属性：数据属性和函数属性。

1. 类的数据属性是共享给对象用的，所有的内存地址都是相同的。
2. 类的函数属性是绑定给对象用的。绑定方法会自动传值，绑定给对象的方法，谁调用，就会将谁作为第一个参数自动传入。

#### 增删改查

属性存在则修改，属性不存在则创建，但是对于内置的类，不可以修改。

```python
class OldBoyClass(object):
    school_name = oldboy
    def __init__(self, name):
        self.name = name

        
        
shanghai_oldboy_school = OldBoyClass(shanghai)

# 属性的增删改查
# 查
print(OldBoyClass.school_name)
# 改
OldBoyClass.school_name=newboy
print(OldBoyClass.school_name)
# 增
OldBoyClass.school_addr=Beijing
# 删
del OldBoyClass.school_addr
```



### 绑定方法

类中定义的函数，需要按照规定的参数来进行传参，有多少参数就需要传进去多少参数，但实际上，类中定义的函数，其实主要是给对象使用的（如果不加装饰器的话），实例化对象后，类中的函数属性是通过绑定方法，绑定给对象，因此哪个对象来调用绑定方法，就会将谁作为第一个参数传给该方法，所以类中定义的函数一般都会加上self，表示第一个传入的对象本身。

### 非绑定方法

就是静态方法，不帮忙自动传参，所有参数都需要自己传入。

### 内置方法

#### 反射

定义：程序可以访问、检测和修改它本身状态或行为的一种能力。

```python
"""
hasattr(object, name: str) -> bool
getattr(object, name: str, default=None) -> # 存在则返回具体值，如果不定义default，不存在直接报错。
setattr(x, y, v)
delattr(x, y)
"""
```



#### 内置方法

```python
"""
isinstance(obj, cls)：检查obj是不是cls的对象。
issubinstance(sub, super)：检查sub是不是super的子类。
__setattr__：更改属性时触发。
__delattr__：删除属性时触发。
__getattr__：调用属性不存在时会触发，不会报错。
__getattribute__：不管属性是否存在，都会触发。
__doc__：描述信息。
__call__：对象后面加括号，会触发执行。
__del__：当对象在内存中被释放时，自动触发执行。
__module__：当前操作的对象在哪个模块。
__class__：当前操作的对象的类是什么。
"""
```



### 元类

type类，就是元类。

#### 单例模式

```python
class Mysql(object):
    __instance=None
    def __init__(self, host, port):
        self.host=host
        self.port=port
    @classmethod
    def singleton(cls, *args, **kwargs):
        if not cls.__instance:
            cls.__instance=cls(*args, **kwargs)
        return cls.__instance
```



## 网络编程

### OSI七层协议

应用层、表示层、会话层

传输层

网络层

数据链路层

物理层

### TCP五层协议

应用层：用户使用的都是应用程序，均工作于应用层，它规定应用程序的数据格式。

传输层：建立端口到端口的通信。

```
TCP协议（可靠的数据传输）：三次握手，四次挥手。

UDP协议（不可靠传输）
```



网络层：引入一套新的地址用来区分不同的广播域/子网，这套地址即为网络地址。

```
IP协议：
	- 规定网络地址的协议叫做IP协议，它定义的地址称之为IP地址，目前广泛采用v4版本即ipv4，它规定网络地址由32位2进制表示。
	- 一个IP地址通常写成四段十进制数，如172.0.0.1
	- 范围0.0.0.0到255.255.255.255
子网掩码：表示子网络特征的一个参数。它在形式上等同于IP地址，也是一个32位二进制数字，它的网络部分全部为1，主机部分全部为0，子网掩码必须和IP地址一起使用。
子网掩码的作用：将某个IP地址划分成网络地址和主机地址。
IP地址分类：
	1. A类IP地址：最高位必须为0，从1.0.0.0到126.0.0.0
	2. B类IP地址：最高位必须为10，从128.0.0.0到191.255.255.255
	3. C类IP地址：最高位必须为110，从192.0.0.0到223.255.255.255
	4. D类IP地址：用于多点广播，最高位为1110，保留地址。
	5. E类IP地址：最高位为11110，保留。
ARP协议：通过广播的方式发送数据包，获取目标主机的mac地址。
```



数据链路层：单纯的电信号0和1没有意义，必须规定电信号多少位一组，定义了电信号的分组方式。

```
以太网协议：
	- 一组电信号构成一个数据包，叫做“帧”。
	- 每一组数据帧分为：报头head和数据data两部分。
head：
	- 发送者/源地址，6个字节
	- 接收者/目标地址，6个字节
	- 数据类型，6个字节
data：具体的数据内容
```



物理层：基于电器特性发送高低电压（电信号），高电压对应1，低电压对应0，计算机之间必须组网。

### SOCKET编程

```
服务端：
	s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
	s.bind(('127.0.0.1', 8888))
	s.lisent(5)
	conn, addr = s.accept()
	conn.send(b'sdfsd')
	conn.recv(1024)
	conn.close()
客户端：
	c = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
	c.connect(('127.0.0.1', 8888))
	c.recv(1024)
	c.send(b'2123')
```

#### 粘包问题

解决办法：通过定制属于自己的数据头，来解决。

### 总结

```
1. TCP（传输控制协议）面向连接的，面向流的，提供高可靠性服务。收发两端（服务端和客户端）都要有一一成对的socket。
2. UDP（用户数据报协议）无连接的，面向消息的，提供高效率服务。
3. TCP是基于数据流的，收发的消息不能为空，需要加入收到消息为空时的处理机制。
```

